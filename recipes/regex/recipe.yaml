about:
  description: "# Mojo Regex\nRegular Expressions Library for Mojo\n\n`regex` is a\
    \ regex library featuring a hybrid DFA/NFA engine architecture that automatically\
    \ optimizes pattern matching based on complexity.\n\nIt aims to provide a similar\
    \ interface as the [re](https://docs.python.org/3/library/re.html) stdlib package\
    \ while leveraging Mojo's performance capabilities.\n\n## Disclaimer \u26A0\uFE0F\
    \n\nThis software is in an early stage of development. Even though it is functional,\
    \ it is not yet feature-complete and may contain bugs. Check the features section\
    \ below and the TO-DO sections for the current status\n\n## Implemented Features\n\
    \n### Basic Elements\n- \u2705 Literal characters (`a`, `hello`)\n- \u2705 Wildcard\
    \ (`.`) - matches any character except newline\n- \u2705 Whitespace (`\\s`) -\
    \ matches space, tab, newline, carriage return, form feed\n- \u2705 Escape sequences\
    \ (`\\t` for tab, `\\\\` for literal backslash)\n\n### Character Classes\n- \u2705\
    \ Character ranges (`[a-z]`, `[0-9]`, `[A-Za-z0-9]`)\n- \u2705 Negated ranges\
    \ (`[^a-z]`, `[^0-9]`)\n- \u2705 Mixed character sets (`[abc123]`)\n- \u2705 Character\
    \ ranges within groups (`(b|[c-n])`)\n\n### Quantifiers\n- \u2705 Zero or more\
    \ (`*`)\n- \u2705 One or more (`+`)\n- \u2705 Zero or one (`?`)\n- \u2705 Exact\
    \ count (`{3}`)\n- \u2705 Range count (`{2,4}`)\n- \u2705 Minimum count (`{2,}`)\n\
    - \u2705 Quantifiers on all elements (characters, wildcards, ranges, groups)\n\
    \n### Anchors\n- \u2705 Start of string (`^`)\n- \u2705 End of string (`$`)\n\
    - \u2705 Anchors in OR expressions (`^na|nb$`)\n\n### Groups and Alternation\n\
    - \u2705 Capturing groups (`(abc)`)\n- \u2705 Alternation/OR (`a|b`)\n- \u2705\
    \ Complex OR patterns (`(a|b)`, `na|nb`)\n- \u2705 Nested alternations (`(b|[c-n])`)\n\
    - \u2705 Group quantifiers (`(a)*`, `(abc)+`)\n\n### Engine Features\n- \u2705\
    \ **Hybrid DFA/NFA Architecture** - Automatic engine selection for optimal performance\n\
    - \u2705 **O(n) Performance** - DFA engine for simple patterns (literals, basic\
    \ quantifiers, character classes)\n- \u2705 **Full Regex Support** - NFA engine\
    \ with backtracking for complex patterns\n- \u2705 **Pattern Complexity Analysis**\
    \ - Intelligent routing between engines\n- \u2705 **SIMD Optimization** - Vectorized\
    \ character class matching\n- \u2705 **Pattern Compilation Caching** - Pre-compiled\
    \ patterns for reuse\n- \u2705 **Match Position Tracking** - Precise start_idx,\
    \ end_idx reporting\n- \u2705 **Simple API**: `match_first(pattern, text) -> Optional[Match]`\n\
    \n## Installation\n\n1. **Install [pixi](https://pixi.sh/latest/)**\n\n2. **Add\
    \ the Package** (at the top level of your project):\n\n    ```bash\n    pixi add\
    \ regex\n    ```\n\n## Example Usage\n\n```mojo\nfrom regex import match_first,\
    \ findall\n\n# Basic literal matching\nvar result = match_first(\"hello\", \"\
    hello world\")\nif result:\n    print(\"Match found:\", result.value().match_text)\n\
    \n# Find all matches\nvar matches = findall(\"a\", \"banana\")\nprint(\"Found\"\
    , len(matches), \"matches:\")\nfor i in range(len(matches)):\n    print(\"  Match\"\
    , i, \":\", matches[i].match_text, \"at position\", matches[i].start_idx)\n\n\
    # Wildcard and quantifiers\nresult = match_first(\".*@.*\", \"user@domain.com\"\
    )\nif result:\n    print(\"Email found\")\n\n# Find all numbers in text\nvar numbers\
    \ = findall(\"[0-9]+\", \"Price: $123, Quantity: 456, Total: $579\")\nfor i in\
    \ range(len(numbers)):\n    print(\"Number found:\", numbers[i].match_text)\n\n\
    # Character ranges\nresult = match_first(\"[a-z]+\", \"hello123\")\nif result:\n\
    \    print(\"Letters:\", result.value().match_text)\n\n# Groups and alternation\n\
    result = match_first(\"(com|org|net)\", \"example.com\")\nif result:\n    print(\"\
    TLD found:\", result.value().match_text)\n\n# Find all domains in text\nvar domains\
    \ = findall(\"(com|org|net)\", \"Visit example.com or test.org for more info\"\
    )\nfor i in range(len(domains)):\n    print(\"Domain found:\", domains[i].match_text)\n\
    \n# Anchors\nresult = match_first(\"^https?://\", \"https://example.com\")\nif\
    \ result:\n    print(\"Valid URL\")\n\n# Complex patterns\nresult = match_first(\"\
    ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\", \"user@example.com\")\n\
    if result:\n    print(\"Valid email format\")\n\n# Find all email addresses in\
    \ text\nvar emails = findall(\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\"\
    , \"Contact john@example.com or mary@test.org\")\nfor i in range(len(emails)):\n\
    \    print(\"Email found:\", emails[i].match_text)\n```\n\n## Performance\n\n\
    The hybrid DFA/NFA architecture provides significant performance benefits:\n\n\
    ### Pattern Performance Characteristics\n\n| Pattern Type | Engine Used | Time\
    \ Complexity | SIMD Optimization | Example |\n|--------------|-------------|-----------------|-------------------|---------|\n\
    | **Literal strings** | DFA + SIMD | O(n/w) | String search vectorization | `\"\
    hello\"`, `\"example.com\"` |\n| **Character classes** | DFA + SIMD | O(n/w) |\
    \ Lookup table vectorization | `\"[a-z]+\"`, `\"[0-9]+\"` |\n| **Built-in classes**\
    \ | DFA/NFA + SIMD | O(n/w) | Pre-built SIMD matchers | `\"\\d+\"`, `\"\\s+\"\
    ` |\n| **Simple quantifiers** | DFA + SIMD | O(n/w) | Vectorized counting | `\"\
    a*\"`, `\"[0-9]{3}\"` |\n| **Anchors** | DFA | O(1) | Position validation | `\"\
    ^start\"`, `\"end$\"` |\n| **Basic groups** | DFA/NFA + SIMD | O(n) to O(nm) |\
    \ Partial vectorization | `\"(abc)+\"`, `\"([a-z]+)\"` |\n| **Alternation** |\
    \ DFA/NFA | O(n) to O(nm) | Engine-dependent | `\"cat\\|dog\"` |\n| **Complex\
    \ patterns** | NFA + SIMD | O(nm) to O(2^n) | Character-level SIMD | Backreferences,\
    \ lookahead |\n\n*Where w = SIMD width (typically 16-32 characters processed per\
    \ instruction)*\n\n## Building and Testing\n\n```bash\n# Build the package\n./tools/build.sh\n\
    \n# Run tests\n./tools/run-tests.sh\n\n# Or run specific test\nmojo test -I src/\
    \ tests/test_matcher.mojo\n\n# Run benchmarks to see performance including SIMD\
    \ optimizations\nmojo benchmarks/bench_engine.mojo\n\n# Run SIMD-specific tests\n\
    mojo test -I src/ tests/test_simd_integration.mojo\n```\n\n## TO-DO: Missing Features\n\
    \n### High Priority\n- [x] Global matching (`findall()`)\n- [x] Hybrid DFA/NFA\
    \ engine architecture\n- [x] Pattern complexity analysis and optimization\n- [x]\
    \ SIMD-accelerated character class matching\n- [x] SIMD-accelerated literal string\
    \ search\n- [x] SIMD capability detection and automatic routing\n- [x] Vectorized\
    \ quantifier processing for character classes\n- [ ] Non-capturing groups (`(?:...)`)\n\
    - [ ] Named groups (`(?<name>...)` or `(?P<name>...)`)\n- [ ] Predefined character\
    \ classes (`\\d`, `\\w`, `\\S`, `\\D`, `\\W`)\n- [ ] Case insensitive matching\
    \ options\n- [ ] Match replacement (`sub()`, `gsub()`)\n- [ ] String splitting\
    \ (`split()`)\n\n### Medium Priority\n- [ ] Non-greedy quantifiers (`*?`, `+?`,\
    \ `??`)\n- [ ] Word boundaries (`\\b`, `\\B`)\n- [ ] Match groups extraction and\
    \ iteration\n- [ ] Pattern compilation object\n- [ ] Unicode character classes\
    \ (`\\p{L}`, `\\p{N}`)\n- [ ] Multiline mode (`^` and `$` match line boundaries)\n\
    - [ ] Dot-all mode (`.` matches newlines)\n\n### Advanced Features\n- [ ] Positive\
    \ lookahead (`(?=...)`)\n- [ ] Negative lookahead (`(?!...)`)\n- [ ] Positive\
    \ lookbehind (`(?<=...)`)\n- [ ] Negative lookbehind (`(?<!...)`)\n- [ ] Backreferences\
    \ (`\\1`, `\\2`)\n- [ ] Atomic groups (`(?>...)`)\n- [ ] Possessive quantifiers\
    \ (`*+`, `++`)\n- [ ] Conditional expressions (`(?(condition)yes|no)`)\n- [ ]\
    \ Recursive patterns\n- [ ] Subroutine calls\n\n### Engine Improvements\n- [x]\
    \ Hybrid DFA/NFA architecture with automatic engine selection\n- [x] O(n) DFA\
    \ engine for simple patterns\n- [x] SIMD optimization for character class matching\
    \ and literal string search\n- [x] Pattern complexity analysis for optimal routing\n\
    - [x] SIMD capability detection for intelligent engine selection\n- [x] Vectorized\
    \ operations for quantifiers and repetition counting\n- [ ] Additional DFA pattern\
    \ support (more complex quantifiers and groups)\n- [ ] Compile-time pattern specialization\
    \ for string literals\n- [ ] Aho-Corasick multi-pattern matching for alternations\n\
    - [ ] Advanced NFA optimizations (lazy quantifiers, cut operators)\n- [ ] Parallel\
    \ matching for multiple patterns\n\n## Contributing\n\nContributions are welcome!\
    \ If you'd like to contribute, please follow the contribution guidelines in the\
    \ [CONTRIBUTING.md](CONTRIBUTING.md) file in the repository.\n\n## Acknowledgments\n\
    \nThanks to Claude Code for helping a lot with the implementation and testing\
    \ of the regex library, and to the Mojo community for their support and feedback.\n\
    \n## License\n\nmojo is licensed under the [MIT license](LICENSE).\n"
  homepage: https://github.com/msaelices/mojo-regex
  license: MIT
  license_file: LICENSE
  repository: https://github.com/msaelices/mojo-regex
  summary: Library for dealing with regular expressions in Mojo
build:
  number: 0
  script:
  - mkdir -p ${PREFIX}/lib/mojo
  - pixi run mojo package regex -o ${PREFIX}/lib/mojo/regex.mojopkg
context:
  version: 13.4.2
package:
  name: regex
  version: 0.1.0
requirements:
  run:
  - max >= 25.4.0
source:
  - git: https://github.com/msaelices/mojo-regex.git
    rev: 98530668c447b66e2735736182b8da71800fb916
